"""
Strategy Interface and Base Classes

This module defines the core interfaces and data structures for strategy execution.
All trading strategies must implement the IStrategy interface.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, List, Any
from datetime import datetime
from enum import Enum


class StrategyStatus(Enum):
    """Strategy execution status"""
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class StrategyConfig:
    """Configuration for strategy execution"""
    strategy_id: str
    account_id: str
    trading_mode: str  # 'paper' or 'live'
    symbols: List[str]
    timeframes: List[str]
    parameters: Dict[str, Any]
    risk_management: Optional['RiskConfig'] = None


@dataclass
class RiskConfig:
    """Risk management configuration for strategy"""
    max_position_size: int = 100
    max_loss_per_trade: float = 1000.0
    stop_loss_percentage: Optional[float] = None
    take_profit_percentage: Optional[float] = None
    trailing_stop_percentage: Optional[float] = None


@dataclass
class Candle:
    """Candlestick data"""
    symbol: str
    timeframe: str
    open: float
    high: float
    low: float
    close: float
    volume: int
    timestamp: datetime
    is_forming: bool = False


@dataclass
class IndicatorValue:
    """Indicator calculation result"""
    symbol: str
    timeframe: str
    indicator_type: str
    value: Any  # Can be float or List[float] for multi-value indicators
    timestamp: datetime


@dataclass
class TimeframeData:
    """Market data for a single timeframe"""
    historical_candles: List[Candle]
    forming_candle: Optional[Candle]
    indicators: Dict[str, IndicatorValue] = field(default_factory=dict)


@dataclass
class MultiTimeframeData:
    """Market data across multiple timeframes for a symbol"""
    symbol: str
    timeframes: Dict[str, TimeframeData]  # {timeframe: TimeframeData}
    current_price: float
    timestamp: datetime


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    type: str  # 'entry' or 'exit'
    direction: str  # 'long' or 'short'
    symbol: str
    quantity: int
    order_type: str  # 'market' or 'limit'
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    trailing_stop_loss: Optional[float] = None
    reason: Optional[str] = None  # Explanation for the signal


@dataclass
class StrategyState:
    """Current state of a strategy instance"""
    strategy_id: str
    account_id: str
    status: StrategyStatus
    config: StrategyConfig
    started_at: datetime
    last_update: datetime
    error_message: Optional[str] = None
    custom_state: Dict[str, Any] = field(default_factory=dict)  # Strategy-specific state


class IStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement this interface to be executed by the platform.
    """
    
    @abstractmethod
    def initialize(self, config: StrategyConfig) -> None:
        """
        Initialize the strategy with configuration.
        
        Called once when the strategy is loaded. Use this to set up
        any initial state, validate parameters, etc.
        
        Args:
            config: Strategy configuration including parameters
        """
        pass
    
    @abstractmethod
    def on_tick(self, data: MultiTimeframeData) -> Optional[Signal]:
        """
        Called on every tick (price update).
        
        This is called frequently, so keep logic lightweight.
        Use this for strategies that need tick-by-tick updates.
        
        Args:
            data: Multi-timeframe market data for the symbol
            
        Returns:
            Optional[Signal]: Trading signal if conditions are met, None otherwise
        """
        pass
    
    @abstractmethod
    def on_candle_complete(self, timeframe: str, candle: Candle, data: MultiTimeframeData) -> Optional[Signal]:
        """
        Called when a candle completes for any subscribed timeframe.
        
        Use this for strategies that make decisions on candle completion.
        This is more efficient than on_tick for most strategies.
        
        Args:
            timeframe: The timeframe that completed (e.g., '1m', '5m')
            candle: The completed candle
            data: Multi-timeframe market data for the symbol
            
        Returns:
            Optional[Signal]: Trading signal if conditions are met, None otherwise
        """
        pass
    
    @abstractmethod
    def cleanup(self) -> None:
        """
        Called when the strategy is stopped.
        
        Use this to clean up resources, save state, etc.
        """
        pass
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get custom strategy state for persistence.
        
        Override this to save strategy-specific state to Redis.
        
        Returns:
            Dict containing strategy state
        """
        return {}
    
    def set_state(self, state: Dict[str, Any]) -> None:
        """
        Restore strategy state from persistence.
        
        Override this to restore strategy-specific state from Redis.
        
        Args:
            state: Previously saved strategy state
        """
        pass
